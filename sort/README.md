## 정렬 알고리즘

### 선택정렬

- 작은 숫자를 앞으로 보내면서 구현
- 효율적이지 않음
- 구현이 쉽다
- 시간복잡도 O(N^2)

### 버블정렬

- 옆에 있는 값과 비교해서 더 작은값을 앞으로 보낸다
- 가장 비효율적인 알고리즘
- 시간복잡도 O(N^2)

### 삽입정렬

- 각 숫자를 적절한 위치에 삽입하여 정렬
- 비효율적인 알고리즘
- 시간복잡도 O(N^2)을 가지는 알고리즘(선택, 버블, 삽입)중에서 가장 강력함
- 시간복잡도 O(N^2)

### 퀵정렬

- 피벗을 기준으로 큰 숫자와 작은 숫자를 나누는 방식
- 가장 앞에 있는 값을 주로 피벗으로 사용함
- 대표적인 분할정복 알고리즘
- 평균 시간복잡도 O(N\*logN)
- 최악 시간복잡도 O(N^2)

### 병합정렬

- 분할정복 방법 채택
- 배열을 반으로 분할하고 나중에 합친다
- 정렬된 배열을 저장하기 위한 메모리가 추가로 필요하다
- 평균 시간복잡도 O(N\*logN)

### 힙정렬

- 힙 생성 알고리즘(heapify) 사용
- heapify를 사용했더라도 부분적으로 최대/최소힙이 붕괴되지 않았는지 확인이 필요하다
- 힙 구조를 만드는 시간복잡도 O(N)
- heapify 평균 시간복잡도 O(N\*logN)
- 평균 시간복잡도 O(N + N\*logN) = O(N\*logN)

### 계수정렬

- 크기를 기준으로 갯수를 세는 알고리즘
- 전체의 데이터 크기만큼 허용할 수 있는 배열을 만들어야한다 -> 정렬할 데이터 자체의 크기에 의존을 받는 알고리즘
- 데이터의 크기가 한정되어야 사용할 수 있다
- 평균 시간복잡도 O(N)
